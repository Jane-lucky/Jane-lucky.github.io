---
title: 日志收集实战

---

## 如何结束子goroutine

1. 全局变量

```go
package main

import (
	"fmt"
	"sync"
	"time"

	_ "github.com/go-sql-driver/mysql"
)

var wg sync.WaitGroup

//设置全局变量
var exit bool

func worker() {
	defer wg.Done()
	for {
		fmt.Println("...worker...")
		time.Sleep(time.Second)
		if exit {
			break
		}
	}
}

func main() {
	wg.Add(1)
	go worker()

	time.Sleep(time.Second * 5)
	exit = true
	wg.Wait()
	fmt.Println("...over...")

}
```

2. channel的方式实现

```go
package main

import (
	"fmt"
	"sync"
	"time"

	_ "github.com/go-sql-driver/mysql"
)

var wg sync.WaitGroup

//channel

func worker(ch <-chan bool) {
	defer wg.Done()
LABEL:
	for {
		select {
		case <-ch:
			break LABEL
		default:
			fmt.Println("...worker...")
			time.Sleep(time.Second)
		}

	}
}

func main() {
	var exitChan = make(chan bool, 1)
	wg.Add(1)
	go worker(exitChan)

	time.Sleep(time.Second * 5)
	exitChan <- true
	wg.Wait()
	fmt.Println("...over...")

}

```

3. **context**
   - 控制多个goroutine退出

```go
package main

import (
	"context"
	"fmt"
	"sync"
	"time"

)

var wg sync.WaitGroup

//channel

func worker(ctx context.Context) {
	defer wg.Done()
LABEL:
	for {
		fmt.Println("...worker...")
		time.Sleep(time.Second)
		select {
		case <-ctx.Done():
			break LABEL
		default:
		}
	}
}

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	wg.Add(1)
	go worker(ctx)

	time.Sleep(time.Second * 5)
	cancel()
	wg.Wait()
	fmt.Println("...over...")

}

```

```go
package main

import (
	"context"
	"fmt"
	"sync"
	"time"
)

func worker(ctx context.Context) {
LABEL:
	for {

		select {
		case <-ctx.Done():
			break LABEL
		default:
			fmt.Println("...worker1...")
			time.Sleep(time.Second)
		}
	}
}

func worker2(ctx context.Context) {
LABEL:
	for {

		select {
		case <-ctx.Done():
			break LABEL
		default:
			fmt.Println("...worker2...")
			time.Sleep(time.Second)
		}
	}
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
	go worker(ctx)
	go worker2(ctx)
	time.Sleep(time.Second * 5)
	defer cancel()
	go worker2(ctx)
	fmt.Println("...over...")

}

```



### **new和make**

都是初始化内存

new，多用来为基本数据类型初始化内存，返回指针

make：用来初始化（slice、map、chan）,返回对于类型