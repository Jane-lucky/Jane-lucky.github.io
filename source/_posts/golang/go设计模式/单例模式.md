---
title: 单例模式
categories: 
- [golang, go设计模式]
---

# 原理

只能开启一个线程，只有一个实例，并且能够实现自我实例化;

确保一个类只有一个实例，变成单例之后，确保程序运行之后查找的对象均是一个对象。

## 懒汉式

非线程安全，也就是多线程下可能创建多次对象。



线程安全，利用加锁保证线程安全，但由于每次调用都有加锁的操作，性能相较于不高效。

### 不加锁

```go
type singleton struct {
}

var instance *singleton

func GetInstance() *singleton {
	if instance == nil {
		instance = &singleton{}
	}
	return instance
}
```

线程不安全。如果执行多个goroutine（高并发），进行第一次检查都会创建singleton类型的实例，导致创建多个对象，并且会相互覆盖，

### 整体加锁

```go
var mu sync.Mutex

type singleton struct {
}

var instance *singleton

func GetInstance() *singleton {
	mu.Lock()
	defer mu.Unlock()
	if instance == nil {
		instance = &singleton{}
	}
	return instance
}
```

整体进行加锁之后，会使得在执行多个goroutine的时候，所有的都需要加锁和开锁，性能降低。

### 在创建方法的时候加锁

```go
var mu sync.Mutex

type singleton struct {
}

var instance *singleton

func GetInstance() *singleton {

	if instance == nil {
		mu.Lock()
		instance = &singleton{}
		mu.Unlock()
	}
	return instance
}
```

线程不安全。多个线程依旧会创建多个实例。

### 双重检锁

```go
var mu sync.Mutex

type singleton struct {
}

var instance *singleton

func GetInstance() *singleton {

	if instance == nil {
		mu.Lock()
		if instance == nil {
			instance = &singleton{}
		}

		mu.Unlock()
	}
	return instance
}
```

只有当对象未初始化的时候，才会有加减的操作

### sync.Once实现

```go
var once sync.Once

type singleton struct {
}

var instance *singleton

func GetInstance() *singleton {

	once.Do(func() {
		instance = &singleton{}
	})
	return instance
}
```

[`Do`方法源码](https://jane-lucky.github.io/2022/09/09/golang/Golang包/sync.Once/)

## 饿汉式

单例使用较少，并且创建的资源比较多。

直接创建好对象，不需要判断为空，线程安全。

```
type singleton struct {
}

var instance *singleton

func init() {
	instance = &singleton{}
}
func GetInstance() *singleton {
	return instance
}
```

